# 3주차 

배우는 내용은 다음과 같다. 

- 코틀린에서 클래스를 쓰는 법
- 코틀린 객체 지향 프로그래밍.
- Constructor 

## Constructor

- 클래스 안에다가 constructor 를 선언하면 부생성자이다. 그리고 부생성자는 당연히 오버로딩이 된다.
- 클래스 이름 안에다가 `()` 키워드를 붙이면 주생성자이다.
- 부생성자는 반드시 주생성자를 호출해줘야 한다.
- 주생성자와 부생성자는 시그니처가 동일하면 삭제를 해야한다. 
- data class 의 경우에는 주생성자가 필요하고 val, var 키워드를 붙여야 한다. 
- 초기화 코드인 init 은 자바로 보면 주생성자와 합쳐진다. 
- 코틀린 에서는 주생성자에 val, var 키워드를 붙이면 프로퍼티로 바로 사용이 가능하다. 
- 부생성자를 사용해야 하는 경우는 인자의 타입이 달라지는 경우가 있다. 이런 경우는 섞어 쓰지말고 부생성자만 쓰는 것도 괜찮다. 섞여있으면 헷갈리기 떄문에. 팩토리 함수로 뺴내는 경우도 괜찮다.

## OOP

객체지향 언어를 먼저 보자. (이 기능을 지원해야 객체지향을 할 수 있다.)

- 대체가능성: 하위형은 상위형을 대체할 수 있음. 
- 내적동질성: 어떤 형으로 객체를 참조해도 원래 형으로 작동한다. (다이나믹 디스패치가 되느냐 이 차이이다.)

겍체지향 프로그래밍은 변화율에 맞는 자기만의 일만 하고 그외는 다른 객체에게 밀어야한다. 

리마인더를 만들면서 객체지향 프로그래밍을 보자.

- 리마인더는 정해진 내용이 정해진 시간에 전달된다. 
  - User, Item, Scheduler, Sender, Looper 을 도출해줄 수 있다.
  - 도출은 변하는 부분을 바탕으로 쪼개고 역할을 뽑아내면 된다. 
  - 내용은 Item 
  - 시간을 체크하는 것. 정해진 시간은 Scheduler
  - 보내는 역할은 Sender
  - 이용하는 사람은 User
  - 계속해서 이벤트가 있는지 확인하는 과정이 필요하니까 Looper 가 필요하다. 
- 관계도 도출해보자. 
  - User 마다 Item 이 있어야 한다. 근데 Item 은 User 를 알면 안된다. (의존성을 설정할 땐 순환의존성이 있으면 안된다는 것 JPA 같은 것을 쓸 때 문제겠지.)
  - 의존성은 유연성을 담당한다. Item 이 Scheduler 를 참조하면 각 Item 마다 스케쥴을 다르게 하는게 가능하다. 
  - Schedule 이 Item 을 가지고 있다면 정해진 것만 사용이 가능하고 모든 Item 은 동일한 Schedule 을 가진다.
  - Scheduler 는 Sender 를 참조해야한다. 정해진 시간이 딱 되면 보내져야 하니까.
  - Looper 는 User 별로 보낼게 있는지 확인해야 하니까 User 를 의존한다. 

## ETC

- open 클래스의 open 메소드여야지 오버라이딩이 된다.
- 스태틱을 사용하고 있다면 문제가 있다. 스태틱이 사용 가능한 경우는 팩토리 말고는 없다. (결합도를 높이지 말자.)
- push 기반으로 만드는 서비스가 event-driven 이다. 
- list 는 data class 를 쓰는게 맞고 아니라면 set 을 써야한다. 객체지향에서는.
- by lazy 는 사용하기 전까지 만들지 않는다. 
- 유저 스레드는 함부러 종료되지 않는다. interrupt 가 걸려있는 상태에서 종료를 해줘야한다.
- 인터페이스에게 상태가 필요하면 추상 클래스가 되야한다. 
- 템플릿 패턴은 전략패턴으로 대체하는게 가능하다.
  - 각각 장단점이 있다. 
  - 코드상의 스펙을 보고 알려면 템플릿 메소드 
  - 런타임 상의 유연함을 줄려면 전략 패턴. (클래스를 줄일 수 있다.)
- 절차 지향 프로그래밍은 프로서지 지향 프로그래밍을 말한다. 
  - 프로시저는 리턴이 없는 함수를 말한다. 
  - 프로시저에 모든 걸 처리하는 프로그래밍을 말한다. (쓰레기통에 너가 모든걸 처리해 약간 느낌.)
- TDD 의 문제는 밑에서 쌓아올린 서브모듈이 상위 개념인 메시지와 달라지면서 다시 만드는 문제가 있을 수 있다. 
