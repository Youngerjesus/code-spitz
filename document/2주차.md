## 2주차 배울 내용

JSON Stringify 만들기. 

- 함수와 제네릭 인자 설정
- 리플렉션 KClass, KCallable, KProperty, KFunction
- 코틀린 컬렉션 구조 개괄
- 이터레이션 관련 메소드 filter, filterIsInstance, forEach, joinTo 등 
- 문자열 템플릿
- 함수 인자의 기본값과 기명 인자 사용
- 스마트 캐스팅
- 확장 함수, 확장 람다
- StringBuilder 의 효과적인 사용 
- 내장 함수 run, apply, also, let
- 코틀린 애노테이션
- 리플렉션으로 에노테이션 사용
- 널가능형과 널체인여난자, 엘비스 연산자 


## KClass 

- 클래스::class 를 쓰면 코틀린 클래스의 정보를 얻을 수 있다.
- KClass.members 에소 속성과 메소드를 얻을 수 있다. 이때 타입은 `Collection<KCallable>` 이다. 
- 자바 리플렉션과 코틀린 리플렉션은 다르다. 코틀린 컴파일 과정의 정보에 접근할 수 있는게 코틀린 리플렉션 

## KCallable 
- 모든 호출 가능 요소다. 
  - 내부에는 KProperty 와 KFunction 이 있다. 
- 코틀린에서는 내부적으로 프로퍼티를 만들면 getter, setter 를 자동적으로 만들어진다. 그래서 Callable 에 Property 가 있다.   

## KFunction

- ::함수나, 인스턴스::메소드 를 통해서 함수 호출 참조를 넘길 수 있다. 람다식 대신에. 
- 이런 호출은 람다를 재사용하는게 아니라 호출될 때마다 계속해서 만드는 것이다. 오해하지 말자. 


## Collection

- Collection 의 정보르르 보면 제일 최상위에는 Iterator 가 있다.
  - Array 나 Sequence 도 Iterator 를 상속받고 있다.
  - **ㅁ두 다 공통 부모로 Iterator 를 상속받고 있기 때문에 기본적인 사용 방법은 모두 동일하다.** 자바는 그렇지 않다. 
- Collection 내부에는 List 와 Set Map 이 있다. 
- Collection 은 기본적으로 불변형이다. 

## ETC 

- 코틀린 언어 철학은 생산적인 언어다. 그러므로 코드 짜는 가능성은 줄여준다. 
- 특정 타입만으로 필터를 하고 싶다면 `filterIsInstance` 를 사용할 수 있다. 다형성으로 타입 캐스팅을 해줘야하는 경우라면 이걸 적용하면 코드를 줄여준다. 
- 코틀린 문자에서 `$변수` 이렇게 쓰면 내부적으로 toString() 을 호출시켜준다. 
- Passing trailing lambda 를 통해서 마지막 람다는 밖으로 뺴낼 수 있다.
- Json 스펙은 오브젝트 뿐만 아니라 문자 하나, 숫자 하나, 어레이도 JSON 에 속한다. 
- `val` 로 되어있으면 `is` 로 스마트 캐스팅이 될 수 있다. 코틀린의 스마트 캐스트는 when 절 기준 위에서 아래로 내려가기 때문에 많이 걸리는 타입을 위로 올리는게 유리한다.
- 코드의 중복은 발견되는 것이다. 법칙이 없다. 물론 개발자의 능력에 따라서 발견하는 것이다.
- 함수의 범용성을 늘릴려면 특수한 케이스에 맞추면 안된다. 덜어내야한다. 
- 확장함수의 사용 케이스 중 하나는 자주 반복되는 인스턴스.메소드() 가 있다면 해당 인스턴스의 확장 함수를 만들어서 코드 가독성을 줄 수 있다.
- 코드에서도 트랜잭션이 있다. 중간에 딴 짓을 할 수 없도록 하는 것으로. 이를 위해서는 지역변수 제거가 필요하다. 
- 지역변수의 생성은 중간에 딴 짓을 할 여지가 있다. 그러므로 함수 호출을 위한 변수만이 필요하다면 지역변수 제거를 위해서 확장 함수를 사용가능하다.
  - 확장 함수는 4가지가 있다. apply(T.()->Unit): T, also((T)->Unit): T  run(T.()->R): R, let((T) -> R): R
- 애노테이션은 주석보다 더 명확한 정보를 줄 수 있다. (주석보다 애노테이션을 쓰자.)

