# 4주차

배우는 내용 

- JsonParser 를 만들어 보면서 배우자. 

## Operator 

- 코틀린에서는 함수에 operator 를 붙일 수 있다.
- 언어 시스템에는 연산자와 문법이 있다.
  - 연산자는 논리, 산술, 비교, 할당을 말하고 
  - 문법은 그 언어의 문법을 말한다.
  - 대부분의 언어 자바같은 언어는 제공해주는 기능을 구현하려면 언어가 제공해주는 클래스를 상속받아서 구현해야한다.
  - 코틀린은 사용자 객체가 언어 시스템과 연동하기 위해 타입 계층을 변화시키지 않고 operator 키워드만 붙이면 된다. 즉 코틀린은 operator 만 있으면 된다 자바와는 달리.
  - operator 는 코틀린 내의 연산자를 나만의 방식으로 쓸 수 있는 방법을 말하는듯. 이게 함수에 단순히 넣는것만으로 가능해지니.

````kotlin
class Op(var value: Int) {
    fun plus(add:Int): Int {
        return value + add // Op(5).plus(3) 을 써야한다. 
    }
}

class Op(var value: Int) {
  operator fun plus(add:Int): Int {
    return value + add // Op(5) + 3 연산이 가능해짐. 
  }
}
````

## inline 함수 

- 함수 호출읠 비용을 줄이고 싶다면 inline 함수를 쓰는 방법도 있다. 
- 성능이 필요한 경우에는 얼마나 많이 사용되고 있느냐가 결정한다. 
- 인라인 함수 내부 구조는 인라인 함수보다 가시성이 높아야한다.
- 순환 참조가 있는 경우에는 인라임 함수를 사용할 수 없다. 

## ETC 

- 확신을 가질 수 있을만큼 공부를 하자. 
- 어떻게 써야하는지를 만들고 그거에 대한 서비스를 만드는게 정상적이다. (TDD 와는 대조적)
  - 호스트 코드와 서비스 코드를 분리해라. 호스트 코드의 중복되는 코드는 서비스 코드로 옮겨라. 더 사용하기 쉽도록.
  - 디자인이란 호스트 코드와 서비스 코드의 밸런스를 조정하는 것이다. 어디에 더 제약을 둘 것인지.
- 값 객체는 불변속성이고 사본을 넘겨야 한다. 그래야 제대로 유지된다. (불변이라는 뜻은 레퍼런스를 못바꾼다는 뜻.) 
- `by` 키워드를 통해서 속성 델리게이터를 사용이 가능하다. (getValue() 를 호출한거랑 동일하다. 원래는 getValue() 는 객체의 참조와 Kproperty<*> 을 참고해서 호출한다.)
- 코틀린에서는 실패 가능성에 대해서 널을 리턴한다고 생각하면 된다.
- 확장함수의 장점은 이 함수가 존재한다는 걸 알기가 쉽다는 것. 
- 객체지향에서 역할을 나눴다면 그걸 기억하고 메소드를 부여하는게 중요하다. 계속 기억하지 않으면 이게 모호해진다. 
- 코드의 가독성은 역할이 잘 나눠지지 않았을 때 일어나는 경우가 대부분이다. 
- 코틀린에서는 `as?` 를 통해서 클래스 캐스팅이 실패하면 널이 되도록 할 수 있다. 
- 코틀린에서는 괄호안에서 변수를 선언하는게 가능하다. `when()` 괄호안에서 변수를 선언하는게 가능하다. 지역변수의 범위를 줄이는게 가능. 
- API 사용에 대한 지식은 시시콜콜하다. 찾아보면 된다. 
